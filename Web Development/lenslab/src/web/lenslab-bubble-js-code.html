<div style="position: relative; max-width: 640px; width: 100%; margin: 0 auto;">
    <video id="localVideo" autoplay muted style="width: 100%; height: auto; transform: scaleX(-1);"></video>
    <canvas id="overlay" style="position: absolute; top: 0; left: 0; transform: scaleX(-1);"></canvas>
</div>
<div id="status" style="margin-top: 10px; text-align: center;"></div>
  
<script>
let stream;
let roiCoordinates = [];
let websocket;
let isWebSocketReady = false;
let isCapturing = false;
let isMeasuring = false;
let frameBuffer = [];
let analysisResults = [];
 
function initializeWebcam() {
    
    //Create video, overlay, status, and buttons
    const localVideo = document.getElementById('localVideo');
    const overlay = document.getElementById('overlay');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const status = document.getElementById('status');
  
    async function startCamera() {
          try {
              if (stream) {
                  stream.getTracks().forEach(track => track.stop());
              }
              stream = await navigator.mediaDevices.getUserMedia({video: true});
              localVideo.srcObject = stream;
              status.textContent = 'Camera started';
              startButton.textContent = 'Camera Started';
              startButton.disabled = true;
              stopButton.disabled = false;
  
              localVideo.onloadedmetadata = () => {
                  overlay.width = localVideo.videoWidth;
                  overlay.height = localVideo.videoHeight;
                  drawROIs();
              };
          } catch (error) {
              console.error('Error accessing the camera:', error);
              status.textContent = 'Error accessing the camera: ' + error.message;
          }
      }
  
      startCamera();
  }
  
  function stopWebcam() {
      const localVideo = document.getElementById('localVideo');
      const overlay = document.getElementById('overlay');
      const startButton = document.getElementById('startButton');
      const stopButton = document.getElementById('stopButton');
      const status = document.getElementById('status');
  
      if (stream) {
          stream.getTracks().forEach(track => track.stop());
          localVideo.srcObject = null;
          stream = null;
          status.textContent = 'Camera stopped';
          startButton.textContent = 'Start Camera';
          startButton.disabled = false;
          stopButton.disabled = true;
  
          const ctx = overlay.getContext('2d');
          ctx.clearRect(0, 0, overlay.width, overlay.height);
      }
      stopCapture();
  }
  
  function drawROIs() {
      const overlay = document.getElementById('overlay');
      const ctx = overlay.getContext('2d');
      const width = overlay.width;
      const height = overlay.height;
      const squareSize = Math.min(width, height) / 10;
  
      ctx.clearRect(0, 0, width, height);
      
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.font = '16px Arial';
      ctx.fillStyle = 'red';
  
      ctx.scale(-1, 1);
      ctx.translate(-width, 0);
  
      roiCoordinates = [
          {x: width / 2 - squareSize / 2, y: height / 2 - squareSize / 2, size: squareSize, label: 'C'},
          {x: squareSize, y: squareSize, size: squareSize, label: 'UL'},
          {x: width - 2 * squareSize, y: squareSize, size: squareSize, label: 'UR'},
          {x: squareSize, y: height - 2 * squareSize, size: squareSize, label: 'LL'},
          {x: width - 2 * squareSize, y: height - 2 * squareSize, size: squareSize, label: 'LR'}
      ];
  
      roiCoordinates.forEach((roi, index) => {
          drawSquare(ctx, roi.x, roi.y, roi.size);
          drawLabel(ctx, roi.x, roi.y, roi.size, roi.label, index);
      });
  
      ctx.setTransform(1, 0, 0, 1, 0, 0);
  }
  
  function drawSquare(ctx, x, y, size) {
      ctx.strokeRect(x, y, size, size);
  }
  
  function drawLabel(ctx, x, y, size, label, index) {
      const padding = 5;
      const bgHeight = 40;
      const bgWidth = 60;
      
      // Determine position for label background
      let bgX, bgY;
      if (label === 'C') {
          bgX = x + size + padding;
          bgY = y + (size - bgHeight) / 2;
      } else if (label === 'UL') {
          bgX = x + size + padding;
          bgY = y;
      } else if (label === 'UR') {
          bgX = x - bgWidth - padding;
          bgY = y;
      } else if (label === 'LL') {
          bgX = x + size + padding;
          bgY = y + size - bgHeight;
      } else if (label === 'LR') {
          bgX = x - bgWidth - padding;
          bgY = y + size - bgHeight;
      }
  
      // Draw white background
      ctx.fillStyle = 'white';
      ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
  
      // Draw label and value
      ctx.fillStyle = 'red';
      ctx.fillText(label, bgX + 5, bgY + 20);
      if (analysisResults[index] !== undefined) {
          ctx.fillText(analysisResults[index].toFixed(2), bgX + 5, bgY + 35);
      }
  }
  
  function startCapture() {  
      if (isCapturing) return;
      isCapturing = true;
      const ngrokUrl = 'wss://lenslab.ngrok.app/';
      console.log('Attempting to connect to WebSocket at:', ngrokUrl);
      websocket = new WebSocket(ngrokUrl);
      websocket.onopen = () => {
          console.log('WebSocket connection established');
          isWebSocketReady = true; 
      };
      websocket.onmessage = (event) => {
          console.log('Received message from server:', event.data);
          const results = JSON.parse(event.data);
          displayResults(results);
      };
      websocket.onerror = (error) => {
      console.error('WebSocket error:', error);
      console.error('WebSocket readyState:', websocket.readyState);
      stopCapture();
  };
      websocket.onclose = () => {
          console.log('WebSocket connection closed');
          isWebSocketReady = false;
          stopCapture();
      };
  }
  
  function stopCapture() {
      isCapturing = false;
      isMeasuring = false;
      if (websocket) {
          websocket.close();
      }
  }
  
  function startMeasurement() {
      const metricSelector = document.getElementById('qualityMetricSelector');
      const selectedMetric = metricSelector.value;
      console.log('Selected metric:', selectedMetric);
  
      if (!selectedMetric) {
          alert('Please select a quality metric before starting measurement.');
          return;
      }
      
      if (!selectedMetric) {
          console.error('No metric selected. Please choose a metric before starting measurement.');
          return;
      }
  
      if (!isCapturing) {
          startCapture();
      }
      isMeasuring = true;
      captureAndSendFrames();
  }
  
  function stopMeasurement() {
      isMeasuring = false;
  }
  
  function captureAndSendFrames() {
      if (!isMeasuring) return;
  
      const video = document.getElementById('localVideo');
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
  
      ctx.scale(-1, 1);
      ctx.translate(-canvas.width, 0);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
  
      const frames = roiCoordinates.map((roi, index) => {
          const roiCanvas = document.createElement('canvas');
          roiCanvas.width = roi.size;
          roiCanvas.height = roi.size;
          const roiCtx = roiCanvas.getContext('2d');
          roiCtx.drawImage(canvas, roi.x, roi.y, roi.size, roi.size, 0, 0, roi.size, roi.size);
          return {
              index: index,
              dataUrl: roiCanvas.toDataURL('image/jpeg', 0.8)
          };
      });
  
      frameBuffer.push(frames);
      if (frameBuffer.length >= 10 && isWebSocketReady) {
          const metricSelector = document.getElementById('qualityMetricSelector');
          const selectedMetric = metricSelector.value;
  
          if (!selectedMetric) {
              console.error('No metric selected. Stopping measurement.');
              stopMeasurement();
              return;
          }
          
          const dataToSend = {
              frames: frameBuffer,
              metric: selectedMetric
          };
          
          console.log('Sending frame buffer to server');
          console.log('Frame buffer size:', JSON.stringify(dataToSend).length, 'bytes');
          websocket.send(JSON.stringify(dataToSend));
          frameBuffer = [];
      }
  
      requestAnimationFrame(captureAndSendFrames);
  }
  
  function displayResults(results) {
      console.log('Received analysis results:', results);
      analysisResults = results.map(result => result.quality_score);
      drawROIs(); // Redraw ROIs with updated results
  }
  
  window.initializeWebcam = initializeWebcam;
  window.stopWebcam = stopWebcam;
  window.startMeasurement = startMeasurement;
  window.stopMeasurement = stopMeasurement;
  </script>